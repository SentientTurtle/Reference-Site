package net.sentientturtle.html.context;

import net.sentientturtle.html.Document;
import net.sentientturtle.nee.data.DataSources;
import net.sentientturtle.nee.data.SDEData;
import net.sentientturtle.nee.data.sharedcache.FSDData;
import net.sentientturtle.nee.data.sharedcache.SharedCacheReader;
import net.sentientturtle.nee.data.ResourceLocation;
import org.jspecify.annotations.NonNull;

import java.io.IOException;
import java.nio.file.Path;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.concurrent.atomic.AtomicInteger;

/// HTML generation context object; Representing a single HTML document and it's scope
///
/// HTML is generated by writing to this object, through {@link #write(String)}
public abstract class HtmlContext {
    private final HashSet<String> usedIDs;
    // Cache of string prefixes for numerical IDs. IDs must still be put in `usedIDs` before being handed out
    private final HashMap<String, AtomicInteger> prefixMap;
    // Folder depth for this page; 0 if this page is in the website root (Note: Not necessarily URL root, merely the root of the output folder)
    private final int folderDepth;
    // CSS and Javascript segments have their order retained
    private final LinkedHashSet<String> css;
    private final LinkedHashSet<String> js;
    // External files that need including in the output, keys are file paths relative to output folder, value ResourceData provides file contents
    private final HashMap<Path, ResourceLocation.ResourceData> fileDependencies;

    // EVE-specific fields; These live here because Java generic inference breaks with generic HTML and Element, otherwise HtmlContext could have a generic type for data extension
    public final DataSources dataSources;
    public final SDEData sde;
    public final SharedCacheReader sharedCache;
    public final FSDData fsdData;


    /**
     * Create a new context (See subclasses)
     *
     * @param folderDepth Folder depth for this page; 0 if this page is in the website root (Note: Not necessarily URL root, merely the root of the output folder)
     * @param dataSources EVE Online data
     */
    public HtmlContext(int folderDepth, DataSources dataSources) {
        this.usedIDs = new HashSet<>();
        this.prefixMap = new HashMap<>();
        this.folderDepth = folderDepth;

        this.dataSources = dataSources;
        this.sde = dataSources.SDEData();
        this.sharedCache = dataSources.sharedCache();
        this.fsdData = dataSources.fsdData();
        this.css = new LinkedHashSet<>();
        this.js = new LinkedHashSet<>();
        this.fileDependencies = new HashMap<>();
    }

    /**
     * @param absolutePath Target path, "absolute" from the website root
     * @return Relative path from this page to {@code absolutePath}
     */
    public String pathTo(@NonNull String absolutePath) {
        return "../".repeat(folderDepth) + absolutePath.replace("\\", "/");
    }

    /**
     * @param document Document to link to
     * @return Relative path from this page to {@code document}
     */
    public String pathTo(@NonNull Document document) {
        return "../".repeat(folderDepth) + document.getPath();
    }

    /**
     * @param css CSS segment to register
     */
    public void registerCSS(@NonNull String css) {
        this.css.add(css);
    }

    /**
     * @param javascript Javascript segment to register
     */
    public void registerJavascript(@NonNull String javascript) {
        this.js.add(javascript);
    }


    /**
     * Add a file dependency for this page
     * @param path Path to file (relative to website output dir)
     * @param resourceData File contents
     */
    public void addFileDependency(Path path, ResourceLocation.ResourceData resourceData) {
        this.fileDependencies.put(path, resourceData);
    }

    public HashMap<Path, ResourceLocation.ResourceData> getFileDependencies() {
        return fileDependencies;
    }

    // Ordered segments of CSS/JS
    public LinkedHashSet<String> getCSS() {
        return this.css;
    }
    public LinkedHashSet<String> getJavascript() {
        return js;
    }


    /**
     * Requests an ID, providing it if it has not been given out
     * @throws IllegalStateException If the requested ID has already been given out
     */
    public ID tryID(String id) {
        if (this.usedIDs.add(id)) {
            return new ID(id);
        } else {
            throw new IllegalStateException("HTML ID already used: `" + id + "`");
        }
    }

    /**
     * Provides a unique ID consisting of the specified prefix and a numerical suffix
     * <br>
     * Such that <pre>{@code
     * nextWithPrefix("Hello");
     * nextWithPrefix("World");
     * nextWithPrefix("Hello");
     * nextWithPrefix("World");
     * }</pre>
     * Yields the IDs "Hello0", "World0", "Hello1", "World1", etc.
     *
     * @param idPrefix ID prefix
     * @return Next unique ID
     */
    public ID nextIDWithPrefix(String idPrefix) {
        AtomicInteger num = this.prefixMap.computeIfAbsent(idPrefix, _ -> new AtomicInteger());
        while (usedIDs.contains(idPrefix + num.get())) {
            num.incrementAndGet();
        }
        String id = idPrefix + num.get();
        usedIDs.add(id);
        return new ID(id);
    }

    /**
     * Provides an array of unique IDs where all share the same numerical suffix
     * See {@link #nextIDWithPrefix(String)}
     */
    public ID[] nextIDsWithPrefixes(String... idPrefixes) {
        AtomicInteger num = new AtomicInteger(0);
        for (String idPrefix : idPrefixes) {
            var counter = this.prefixMap.computeIfAbsent(idPrefix, _ -> new AtomicInteger());
            if (counter.get() > num.get()) {
                num = counter;
            }
        }

        outer:
        while (true) {
            for (String idPrefix : idPrefixes) {
                if (usedIDs.contains(idPrefix + num.get())) {
                    num.incrementAndGet();
                    continue outer;
                }
            }
            break;
        }

        ID[] ids = new ID[idPrefixes.length];
        for (int i = 0; i < idPrefixes.length; i++) {
            String id = idPrefixes[i] + num.get();
            usedIDs.add(id);
            ids[i] = new ID(id);
        }
        return ids;
    }

    /**
     * Write content to this page
     * @param string Content to write, raw HTML string
     * @return This object, for chaining
     * @throws IOException If a write error occurs
     */
    public abstract HtmlContext write(String string) throws IOException;
}
